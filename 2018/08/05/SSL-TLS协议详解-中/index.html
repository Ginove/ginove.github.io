<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="SSL/TLS协议详解(中)-证书颁发机构"><meta name="keywords" content="Crypto"><meta name="author" content="Ginove,undefined"><meta name="copyright" content="Ginove"><title>SSL/TLS协议详解(中)-证书颁发机构 | Ginove</title><link rel="shortcut icon" href="https://ginove-1252770243.cos.ap-guangzhou.myqcloud.com/%E8%B7%AF%E9%A3%9E/bitbug_favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"CH3QQ87I9H","apiKey":"1005940df08368eb06761af10c531247","indexName":"my-hexo-blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#证书颁发机构的需求"><span class="toc-number">1.</span> <span class="toc-text">证书颁发机构的需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数字签名的定义"><span class="toc-number">2.</span> <span class="toc-text">数字签名的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#证书颁发机构的技术实现"><span class="toc-number">3.</span> <span class="toc-text">证书颁发机构的技术实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果攻击者篡改证书会怎样"><span class="toc-number">4.</span> <span class="toc-text">如果攻击者篡改证书会怎样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信任链"><span class="toc-number">5.</span> <span class="toc-text">信任链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数字签名的数学算法"><span class="toc-number">6.</span> <span class="toc-text">数字签名的数学算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器如何实际验证给定服务器证书的有效性"><span class="toc-number">7.</span> <span class="toc-text">浏览器如何实际验证给定服务器证书的有效性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后续"><span class="toc-number">8.</span> <span class="toc-text">后续</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ginove-1252770243.cos.ap-guangzhou.myqcloud.com/%E8%B7%AF%E9%A3%9E/toui.jpg"></div><div class="author-info__name text-center">Ginove</div><div class="author-info__description text-center">Keep optimistic and Never give up</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">22</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://api.dujin.org/bing/1920.php)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Ginove</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">SSL/TLS协议详解(中)-证书颁发机构</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-05</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>&emsp;&emsp;<a href="https://xz.aliyun.com/t/2526" target="_blank" rel="noopener">上一篇</a>中，我们讨论了关于Diffie Hellman算法的SSL/TLS密钥交换。我们最终认为需要第三方来验证服务器的真实性，并提出了<strong>证书颁发机构</strong>的机制。博客系列的最后两部分的主要内容：</p>
<blockquote>
<ul>
<li>TLS加密客户端-服务器通信并阻止中间人攻击。</li>
<li>编码，散列和加密之间的区别</li>
<li>TLS使用对称密钥加密来加密数据和公钥基础结构以交换对称密钥。</li>
<li>密钥交换算法本身可能被攻击者欺骗。因此，我们需要一个值得信赖的权威来验证服务器的真实性。<a id="more"></a>
</li>
</ul>
</blockquote>
<h3 id="证书颁发机构的需求"><a href="#证书颁发机构的需求" class="headerlink" title="证书颁发机构的需求"></a>证书颁发机构的需求</h3><p>&emsp;&emsp;想象一下，客户端浏览器正在尝试与Web服务器通信，并且想要启动TLS通道。从上面的最后一点来看，为了证明服务器的身份，客户端浏览器必须具有服务器的公钥。但是，我们在浏览器中无法存储要访问的所有网站的公钥，而且由于每分钟都有新的网站出生，因此每分钟都需要更新一次。</p>
<p>&emsp;&emsp;解决这个问题的方案是采用证书颁发机构机制。当我们安装浏览器或操作系统时，将会附有一组证书颁发机构，例如DigiCert。当浏览器自带DigiCert时，这意味着浏览器具有DigiCert的公钥，网站可以向DigiCert索取证书和签名。因此，DigiCert将使用DigiCerts私钥在服务器证书上进行加密签名。当我们发起连接时，服务器将发送嵌入了其公钥的证书。由于浏览器具有DigiCert的公钥，因此可以在服务器证书上验证DigiCert的签名，同时也说明证书上写的服务器的公钥是可信的。</p>
<p>如果您没有完全理解这个概念，也请不要担心。让我们把这个过程细化再逐一分析。</p>
<h3 id="数字签名的定义"><a href="#数字签名的定义" class="headerlink" title="数字签名的定义"></a>数字签名的定义</h3><p>&emsp;&emsp;要理解证书颁发机构的概念，我们可以回顾几十年前的传统邮箱邮件系统并进行类比。想象一下，Alice拥有一家公司，而Bob则是该公司的员工，Alice想给Bob发一封机密邮件，作为首席执行官的Alice，将起草邮件并将其放入邮箱，它将经过几个邮局和几个邮递员并最终到达Bob的手中，Bob可以打开阅读它，但Bob如何确保邮件真的来自Alice？这里有两种可能性：<br>1.攻击者Eve可以使用任何内容起草邮件，将发件人地址设置为类似于Alice的办公室的地址并将其转发给Bob。<br>2.Eve可以是中间人，例如中间邮局的员工，他可以在邮件到达Bob之前打开邮件，他甚至可以按照自己的意愿重写内容，然后将其重新发送给Bob。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180805223523-c99918d6-98bc-1.png" alt="1" title="1"><br>在这两种情况下，都无法确保收到的Alice邮件是否有效。这种时候我们会做什么？查看签名，Alice可以在邮件发布给Bob时使用印章签名，Alice的公司印章可用于验证电子邮件的真实性和完整性。由于Alice的公司是公认的实体，如果邮件有签名，我们可以信任它，这正是证书颁发机构所做的事情。</p>
<h3 id="证书颁发机构的技术实现"><a href="#证书颁发机构的技术实现" class="headerlink" title="证书颁发机构的技术实现"></a>证书颁发机构的技术实现</h3><p>&emsp;&emsp;我们知道<a href="https://www.wst.space/ssl-part-2-diffie-hellman-key-exchange/" target="_blank" rel="noopener">PKI用于在TLS协议中交换会话密钥</a>，此过程可以称为身份验证过程。为了执行认证过程，服务器需要向客户端发送公钥，但是中间攻击者可以获取此公钥并将其替换为自己的公钥，这是非常危险的，因为客户永远不会知道公钥在传输过程中是否被第三方篡改过。客户端会在不知不觉中使用攻击者的公钥加密对称密钥并转发出去，由于攻击者持有相应的私钥，他就可以解密并窃取数据。</p>
<p>为了使客户端信任所接收的公钥，引入CA的概念。 CA的工作如下。假设服务器<a href="https://example.com" target="_blank" rel="noopener">https://example.com</a> 需要TLS证书。<br>1.服务器 example.com将从CA请求TLS证书，例如Digicert。<br>2.Digicert将为example.com创建证书，证书将包含必要的数据，例如服务器名称，服务器的公钥等。<br>3.Digicert将创建数据（证书）的哈希值，并使用自己的私钥对其进行加密。<br>4.浏览器和操作系统自带Digicert等权威机构的公钥。<br>5.当浏览器收到签名证书时，它将使用公钥从签名生成哈希值，它还将使用证书中指定的散列算法生成数据（证书）的散列，如果两个哈希值匹配，则签名验证成功并且证书是可信的。<br>6.现在浏览器可以使用证书中指定的example.com的公钥继续进行身份验证过程。<br>在这里，我们可以将Digicert称为<strong>Root CA</strong>.<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180805223524-c9b473ba-98bc-1.png" alt="2" title="2"></p>
<h3 id="如果攻击者篡改证书会怎样"><a href="#如果攻击者篡改证书会怎样" class="headerlink" title="如果攻击者篡改证书会怎样"></a>如果攻击者篡改证书会怎样</h3><p>&emsp;&emsp;收到证书后，浏览器将验证服务器名称、证书有效性、签名等数据。想象一下，如果攻击者使用他的自定义证书而不是example.com的证书，然后服务器名称字段验证将失败，浏览器将立即断开连接。</p>
<p>&emsp;&emsp;另一种情况是，如果攻击者保留所有这些数据并用公钥替换公钥会发生什么？在这种情况下，当浏览器尝试从证书数据重新生成哈希时，由于数据被篡改，他将获得不同的哈希值，从而数据和签名计算出的哈希值将不匹配。</p>
<p>&emsp;&emsp;为了绕过上述机制，攻击者需要使签名来匹配数据，为了做到这点，他需要拥有Digicert的私钥（最初为example.com签发并签署了证书），所以攻击者此时会失败，因为他可以创建的唯一签名来自他的私钥，我们的浏览器并不会信任这一点。浏览器的证书存储区也不会有攻击者的公钥，并且在发生此类攻击时会显示证书异常，如下所示。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180805223524-c9c413c4-98bc-1.png" alt="3" title="3"></p>
<p>&emsp;&emsp;您可能已经注意到在尝试为浏览器设置代理时，发生私密错误是因为代理工具在充当中间人，并向浏览器显示自己的证书。如果您信任该证书，则可以点击继续；或者，您可以下载代理证书工具并将其添加到浏览器内的受信任机构列表中，这样，您可以在代理工具中以纯文本形式查看加密数据。</p>
<h3 id="信任链"><a href="#信任链" class="headerlink" title="信任链"></a>信任链</h3><p>&emsp;&emsp;我们知道证书颁发机构是为服务器创建并签署证书，很少有组织从事这项工作，即Digicert，Geotrust，Comodo等。如果他们正在为所有服务器签署证书，则必须为所有签名使用相同的私钥，如果它被盗，那么所有的信任都会丢失。为了解决这个问题并增加更多的平均信息量，引入了<strong>中间CA(intermediate CA)</strong>的概念。</p>
<p>&emsp;&emsp;这个想法很简单。Charles是一个值得信赖的人，并曾经收到了Alice的签名邮件，如果Bob看到Charles的签名，他就会信任这封邮件。现在，Smith是Charles信任的另一个人，如果Smith代表Charles签署了一封来自Alice的邮件，那么Bob将不会一直相信它。这里就出现了信任链：Bob相信Charles和Charles信任Smith，因此BOb可以信任Smith。类似地，intermediate CA是Root CA信任的证书颁发机构。 example.com的证书将由intermediate CA颁发，intermediate CA还将具有将由Root CA签名的证书，并且只有Root CA的详细信息会被存储在浏览器的证书库中。</p>
<p> &emsp;&emsp;因此，在证书验证期间，浏览器信任Digicert Root CA和Digicert Root CA信任intermediate CA，因此浏览器可以信任intermediate CA。在下图中，您可以看到层次结构，<strong>DigiCert SHA2 High Assurance Server CA</strong>是中间证书颁发机构和<strong> DigiCert High Assurance EV Root CA</strong>。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180805223524-c9d15bb0-98bc-1.png" alt="4" title="4"></p>
<p>此层次结构的另一个优点是Root CA无需始终在线。</p>
<h3 id="数字签名的数学算法"><a href="#数字签名的数学算法" class="headerlink" title="数字签名的数学算法"></a>数字签名的数学算法</h3><p>&emsp;&emsp;我们在理解密钥交换过程的同时讨论了Diffie-Hellman算法。类似地，也有许多算法可用于数字签名，这写会在服务器证书中指定。请参阅下面的example.com证书。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180805223524-c9dc507e-98bc-1.png" alt="5" title="5"></p>
<p>&emsp;&emsp;我不会多谈核心的数学知识，因为它很无聊，而且我也很菜。证书显示带有RSA加密的SHA-256。 RSA是一种流行的签名算法，我会在这里讨论。与任何其他非对称加密算法一样，RSA也具有公钥 - 私钥对。这里的区别在于，签名（将其视为加密）是通过使用intermediate CA的私钥来完成的。并且签名验证（将其视为解密）由浏览器使用相应的公钥完成的。换句话说，<a href="https://www.cs.cornell.edu/courses/cs5430/2015sp/notes/rsa_sign_vs_dec.php" target="_blank" rel="noopener">RSA签名不是RSA解密</a>。如果您有兴趣制作实用的RSA签名，请<a href="https://askubuntu.com/questions/679230/how-to-sign-files-with-ubuntu-command-line-tools-and-my-own-keys" target="_blank" rel="noopener">参阅此处</a>。</p>
<p>&emsp;&emsp;RSA将在签署之前会对证书进行哈希处理，这有一个很重要的原因。如果您深入了解算法，您将知道如果数据长度超过其密钥长度，RSA无法加密数据。假设我们使用2048位密钥进行加密，那么证书数据不应超过2048位，也就是255个字节，这并不总是可行的，因为证书包含很多信息。因此，在加密之前，在证书上应用散列函数，该函数生成指定长度的唯一随机字符串。在example.com的情况下，使用SHA-256哈希算法。如果您有兴趣，可以进一步<a href="https://crypto.stackexchange.com/questions/12768/why-hash-the-message-before-signing-it-with-rsa" target="_blank" rel="noopener">研究RSA的这种限制</a>。</p>
<h3 id="浏览器如何实际验证给定服务器证书的有效性"><a href="#浏览器如何实际验证给定服务器证书的有效性" class="headerlink" title="浏览器如何实际验证给定服务器证书的有效性"></a>浏览器如何实际验证给定服务器证书的有效性</h3><p>&emsp;&emsp;我们知道服务器使用中级证书颁发机构的签名，因此，在与浏览器通信时，服务器将共享两个证书：一，包含服务器的公钥，即实际的服务器证书；二，由Root CA颁发的intermediate CA证书。以下是验证链的图示。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180805223524-c9ec2cd8-98bc-1.png" alt="6" title="6"></p>
<p>&emsp;&emsp;在签名验证期间，浏览器首先使用已经存储在浏览器中的Root CA的公钥来验证中间证书的数字签名，如果成功，浏览器现在可以信任中间证书及其公钥。现在使用此公钥，浏览器将验证原始服务器证书的签名，该组织可以注册为intermediate CA，以便为其域签署证书。比如谷歌。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180805223524-c9f701e4-98bc-1.png" alt="71" title="71"></p>
<p>&emsp;&emsp;谷歌互联网管理局G3是一个由全球认证Root CA -R2信任的intermediate CA，这意味着，Google可以使用此intermediate CA验证其域名，由于谷歌浏览器是全球认证Root CA认证的，其他浏览器将信任它。必须注意的是，谷歌有权单独签署他们的域名。这可以防止Google为Microsoft签署证书。</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>到目前为止，我们已经讨论了证书颁发机构和TLS协议的原理。在本系列的下一部分中，我们将实际检查整个TLS通信。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ginove</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ginove.github.io/2018/08/05/SSL-TLS协议详解-中/">https://ginove.github.io/2018/08/05/SSL-TLS协议详解-中/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ginove.github.io" target="_blank">Ginove</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Crypto/">Crypto</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/08/07/Bucket上传策略和URL签名的绕过与利用/"><i class="fa fa-chevron-left">  </i><span>Bucket上传策略和URL签名的绕过与利用</span></a></div><div class="next-post pull-right"><a href="/2018/08/05/SSL-TLS协议详解-下/"><span>SSL/TLS协议详解(下)-TLS握手协议</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  owner: 'ginove',
  repo: 'ginove.github.io',
  oauth: {
    client_id: '8c123d3802de7afc9635',
    client_secret: 'ec2035d90649bfa051c5b990447e10a0c70755b7'
  }
})
gitment.render('gitment-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2018 By Ginove</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/algolia.js"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>