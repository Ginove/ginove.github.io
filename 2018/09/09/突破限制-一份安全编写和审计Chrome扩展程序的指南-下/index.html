<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="突破限制-一份安全编写和审计Chrome扩展程序的指南(下)"><meta name="keywords" content="技术文章"><meta name="author" content="Ginove,undefined"><meta name="copyright" content="Ginove"><title>突破限制-一份安全编写和审计Chrome扩展程序的指南(下) | Ginove</title><link rel="shortcut icon" href="https://ginove-1252770243.cos.ap-guangzhou.myqcloud.com/%E8%B7%AF%E9%A3%9E/bitbug_favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"CH3QQ87I9H","apiKey":"1005940df08368eb06761af10c531247","indexName":"my-hexo-blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#偷窥扩展程序中未被污染的安全反模式"><span class="toc-number">1.</span> <span class="toc-text">偷窥扩展程序中未被污染的安全反模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内容脚本不服从任何限制或CSP策略"><span class="toc-number">1.0.1.</span> <span class="toc-text">内容脚本不服从任何限制或CSP策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无法信任的网页DOM"><span class="toc-number">1.0.2.</span> <span class="toc-text">无法信任的网页DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#必须验证JavaScript-DOM事件"><span class="toc-number">1.0.3.</span> <span class="toc-text">必须验证JavaScript DOM事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不能信任网页发送的消息"><span class="toc-number">1.0.4.</span> <span class="toc-text">不能信任网页发送的消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#君子不立危墙"><span class="toc-number">1.0.5.</span> <span class="toc-text">君子不立危墙</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#正确的URL解析"><span class="toc-number">1.0.6.</span> <span class="toc-text">正确的URL解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#点击劫持以及web-accessible-resources的使用注意事项"><span class="toc-number">1.0.7.</span> <span class="toc-text">点击劫持以及web_accessible_resources的使用注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用tarnish自动化审核流程"><span class="toc-number">1.0.8.</span> <span class="toc-text">使用tarnish自动化审核流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#点击此处试用Chrome扩展程序分析仪tarnish"><span class="toc-number"></span> <span class="toc-text">点击此处试用Chrome扩展程序分析仪tarnish</span></a></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ginove-1252770243.cos.ap-guangzhou.myqcloud.com/%E8%B7%AF%E9%A3%9E/toui.jpg"></div><div class="author-info__name text-center">Ginove</div><div class="author-info__description text-center">Keep optimistic and Never give up</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">24</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://api.dujin.org/bing/1366.php)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Ginove</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">突破限制-一份安全编写和审计Chrome扩展程序的指南(下)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-09</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="偷窥扩展程序中未被污染的安全反模式"><a href="#偷窥扩展程序中未被污染的安全反模式" class="headerlink" title="偷窥扩展程序中未被污染的安全反模式"></a>偷窥扩展程序中未被污染的安全反模式</h2><h4 id="内容脚本不服从任何限制或CSP策略"><a href="#内容脚本不服从任何限制或CSP策略" class="headerlink" title="内容脚本不服从任何限制或CSP策略"></a>内容脚本不服从任何限制或CSP策略</h4><p>谈及到后台页面的内容安全策略（CSP）要求时，人们也许会认为跨站点脚本（XSS）在Chrome扩展程序中已经不存在了。但事实并非如此，它只是被附加到了扩展程序的内容脚本端。内容脚本不必遵守扩展声明的CSP，它们也不必遵守它们正在执行的网页的CSP（除非他们将<code>&lt;script&gt;</code>注入到网页的DOM中）。因此，如果<a href="https://example.com" target="_blank" rel="noopener">https://example.com</a> 具有以下CSP：<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script-src &apos;self&apos;; object-src &apos;self&apos;</span><br></pre></td></tr></table></figure></p>
<p>这与在内容脚本上下文中执行的JavaScript完全无关。例如，尽管它被自己的源网页禁止，它也一样可以使用eval()执行他想要的命令。这通常会转化为开发人员通过内容脚本创建Chrome扩展，这些扩展实际上会将新的漏洞引入到热门的网站中，如果不这样做，那么这些漏洞就是安全的。<a href="https://blog.saynotolinux.com/blog/2014/04/12/spooky-sanitizer-stories-analyzing-the-reddit-enhancement-suite-xss-flaw/" target="_blank" rel="noopener">RES XSS漏洞</a>是之前提到的这种情况下的一个很好的例子。尽管Reddit(红迪网(新闻网站名）)没有跨站点脚本（XSS）漏洞，但RES为网站安装了一个扩展程序，它获取用户可以控制的图像标题，并将其作为HTML注入到Reddit的网页DOM中，进而形成了XSS漏洞，所以，Reddit就容易受到所有安装有RES扩展程序的用户的zero-click XSS攻击。<br>在研究这个问题时，反模式就应运而生了。编写内容脚本的开发人员如果让用户使用自己控制的输入来执行不安全的DOM操作，则很有可能会自取灭亡（并祸及他们的用户）。所以扩展程序的开发人员应该万分谨慎，以确保用户不使用诸如<a href="https://gomakethings.com/preventing-cross-site-scripting-attacks-when-using-innerhtml-in-vanilla-javascript/" target="_blank" rel="noopener">innerHTML</a>，html()或设置href (javascript:URIs)之类的调用来执行不安全的DOM操作。</p>
<h4 id="无法信任的网页DOM"><a href="#无法信任的网页DOM" class="headerlink" title="无法信任的网页DOM"></a>无法信任的网页DOM</h4><p>Chrome扩展程序开发人员会涉及的另一个常见反模式是，他们会信任外部网页提供的内容。这存在多种体现形式，例如信任DOM中的数据，从事件侦听器触发的事件，或从网页发送到内容脚本的消息。</p>
<p>就以DOM为例，攻击者可以将布局修改为他们想要的任何格式，以便利用内容脚本。还应值得注意的是，攻击者通过恶意网页访问或通过可信网页中的XSS漏洞来将敏感数据放入DOM中的情况。例如，<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1527&amp;desc=2" target="_blank" rel="noopener">Grammarly Chrome扩展程序就犯了这个错误，因为它们将敏感的身份验证令牌放入所有网页的DOM中，允许恶意网页只是简单地从DOM中提取令牌并使用来对其API进行身份验证</a>。当扩展程序将某种UI放入网页中供用户查看时，这种情况就会更加常见。通常，在这些UI元素中，开发人员会将敏感信息放在Chrome扩展程序之外。更糟糕的是，这些元素通常会被内容脚本再次查询并用于执行可信操作。 这些模式允许攻击者在这些操作中进行攻击并修改DOM元素，从而使其包含非预期的输入。</p>
<h4 id="必须验证JavaScript-DOM事件"><a href="#必须验证JavaScript-DOM事件" class="headerlink" title="必须验证JavaScript DOM事件"></a>必须验证JavaScript DOM事件</h4><p>事件侦听器是内容脚本和网页DOM之间的主要通道之一，它也会受到攻击者的攻击。由于开发人员希望事件完全是由用户操作生成的，而不是由攻击者的一系列动作来创建的，所以这些很会掩人耳目。使用如下脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Create an element to inject</span><br><span class="line">var injected_last_key_element = document.createElement( &quot;div&quot; );</span><br><span class="line">injected_last_key_element.innerHTML = &apos;Last character typed: &lt;div id=&quot;last_keypress_div&quot;&gt;&lt;/div&gt;&apos;;</span><br><span class="line">// Inject this box into the page</span><br><span class="line">document.body.appendChild(</span><br><span class="line">    injected_last_key_element</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// Listen for keydown event and show it&apos;s value in the previously-injected div</span><br><span class="line">document.body.addEventListener( &quot;keydown&quot;, function( keyevent ) &#123;</span><br><span class="line">    document.getElementById( &quot;last_keypress_div&quot; ).innerHTML = keyevent.code;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码实现了侦听keydown事件，并显示被注入文档正文中的<code>&lt;div&gt;</code>内的最后一个按键的代码值。因此，如果您按下键盘上的“a”键，字符串“KeyA”将出现在这个注入的<code>&lt;div&gt;</code>中。以下是关于KeyboardEvent的MDN文档的屏幕截图：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180909095952-0a775692-b3d4-1.png" alt="image.png"></p>
<p>KeyboardEvent.code<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code" target="_blank" rel="noopener">页面</a>说明如下所示：</p>
<blockquote>
<p>“ KeyboardEvent.code属性表示键盘上的物理键（与按键生成的字符相对应）。换句话说，这个属性返回一个不会随键盘布局或键的状态而改变的值。”</p>
</blockquote>
<p>阅读这份文档，作为开发人员的您，可能会认为XSS在这里是不可能存在的。毕竟，这只会显示用户键盘按下的最后一个键码，文档说该属性是“只读”！怎么可能是被用来引起XSS的呢？即使您可以发送合成事件，它也只是预定义的密钥代码，并且<code>&lt;div&gt;</code>将在每个事件上进行重写，对吧？</p>
<p>但如果您这样想，那您就完全错了。实际上，这很容易被攻击者利用。以下便是导致XSS的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// Generate a synthetic key event</span><br><span class="line">function generate_fake_key_event(target_element, key_event_type, custom_properties) &#123;</span><br><span class="line">  var new_event = document.createEvent(</span><br><span class="line">    &quot;KeyboardEvent&quot;,</span><br><span class="line">  );</span><br><span class="line">  for (var property_keyname in custom_properties) </span><br><span class="line">    if (custom_properties.hasOwnProperty(property_keyname)) &#123;</span><br><span class="line">      // Chromium Hack</span><br><span class="line">      Object.defineProperty(new_event, property_keyname, &#123;</span><br><span class="line">        get: function() &#123;</span><br><span class="line">          return custom_properties[property_keyname];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      new_event.initKeyboardEvent(</span><br><span class="line">        key_event_type,</span><br><span class="line">        true,</span><br><span class="line">        true,</span><br><span class="line">        document.defaultView,</span><br><span class="line">        false,</span><br><span class="line">        false,</span><br><span class="line">        false,</span><br><span class="line">        false,</span><br><span class="line">        0,</span><br><span class="line">        0</span><br><span class="line">      );</span><br><span class="line">      new_event[property_keyname] = custom_properties[property_keyname];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  target_element.dispatchEvent(</span><br><span class="line">    new_event</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">// Send a keydown with a code of &lt;img src=x onerror=alert(&apos;XSS&apos;) /&gt;</span><br><span class="line">generate_fake_key_event(</span><br><span class="line">  document.body,</span><br><span class="line">  &quot;keydown&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;code&quot;: &quot;&lt;img src=x onerror=alert(&apos;XSS&apos;) /&gt;&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>上面的代码导致了XSS漏洞，并且会显示带有文本“XSS”的警报：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180909095952-0a846882-b3d4-1.png" alt="image.png"></p>
<p>上述的XSS-警报的例子说明了信任任意事件，会引发的一些严重的缺陷：</p>
<ul>
<li>无需任何用户交互即可生成的事件。</li>
<li>即使事件在文档中有声明类似于“只读”的内容，这也纯粹是为了声明真正创建的事件在生成后不能修改这个属性。它根本不适用于合成生成的事件。</li>
<li>合成生成的事件甚至没有必要遵循事件属性值的预期格式。即使文档说“代码”是预定义的格式，但在合成生成的事件中也不会被强制要求。因此攻击者可以指定<code>&lt;img src=x onerror=alert(‘XSS’) /&gt;</code> 而不是像KeyA这样的东西。</li>
</ul>
<p>这一切听起来都让人非常难受，但还算幸运，我们还可以进行简单的检查来验证事件是否真的是用户生成的。对于用户生成的事件，我们将它的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted" target="_blank" rel="noopener">isTrusted</a>属性设置为true，反之，对于脚本生成的事件，isTrusted属性设置为false。这样我们就可以验证事件是由用户创建的，还是说仅仅是由攻击者合成的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Listen for keydown event and show its value in the previously-injected div</span><br><span class="line">document.body.addEventListener( &quot;keydown&quot;, function( keyevent ) &#123;</span><br><span class="line">    if( keyevent.isTrusted ) &#123;</span><br><span class="line">        document.getElementById( &quot;last_keypress_div&quot; ).innerHTML = keyevent.code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>现在，攻击者已经无法向我们发送破坏性的合成事件了。我们最终处理的所有事件都必须是由用户生成的。虽然isTrusted属性并不常用，但在内容脚本处理网页事件时，它至关重要。</p>
<p>这个例子是经过精心设计的，因为如果攻击者可以在您的页面上创建的任意事件，那么您很可能已经在网页层次上拥有了这些事件，所以，由此导致的网页中的XSS是循环的。一个真实环境的例子是，后台页面使用内容脚本检索的事件数据来做一些不安全的事情，为了简单起见，我们只在常规网页中演示JavaScript事件欺骗。</p>
<h4 id="不能信任网页发送的消息"><a href="#不能信任网页发送的消息" class="headerlink" title="不能信任网页发送的消息"></a><strong>不能信任网页发送的消息</strong></h4><p>Chrome扩展程序中的另一个常见模式是使用JavaScript的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">postMessage()</a>将消息传递到后台页面中调用特定的Chrome扩展API。通常，内容脚本通过事件监听器从网页发出消息，然后将消息中传递到后台页面以调用某些专用的Chrome API。这创建了一个直接通道，任何网页都可以使用特定的Chrome扩展API，如果开发人员没有<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Security_concerns" target="_blank" rel="noopener">检查消息的来源</a>，则会发生一些让人极其不愉快的事情。</p>
<p>通常，即使开发人员会检查收到的消息的来源，他们也会用类似于以下的代码来进行检查：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener( &quot;message&quot;, function( received_message ) &#123;</span><br><span class="line">    // Check to make sure this a sub-domain of our site</span><br><span class="line">    if( received_message.origin.indexOf( &quot;.trusteddomain.com&quot; ) !== -1 ) &#123;</span><br><span class="line">        process_message( received_message );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure></p>
<p>或者，如果他们是正则表达式的忠实使用者，他们将进行类似于下面的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">received_message.match(/https:\/\/www\.trusteddomain\.com/i)</span><br><span class="line">...</span><br><span class="line">received_message.match(/https?:\/\/www.trusteddomain.com$/i)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>令人抱憾的是，所有这些检查都是可以绕过去的，下面是绕过每个检查的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Bypassed with https://a.trusteddomain.com.attacker.com</span><br><span class="line">received_message.origin.indexOf( &quot;.trusteddomain.com&quot; ) !== -1</span><br><span class="line"></span><br><span class="line">// Also bypassed with https://a.trusteddomain.com.attacker.com</span><br><span class="line">received_message.match(/https?:\/\/www\.trusteddomain\.com/i)</span><br><span class="line"></span><br><span class="line">// Bypassed with https://wwwatrusteddomain.com</span><br><span class="line">received_message.match(/https?:\/\/www.trusteddomain.com$/i)</span><br></pre></td></tr></table></figure></p>
<p>这几乎可以肯定是因为收到的消息的origin属性是站点的原始字符串，而不是已解析过的原始部分的对象。众所周知，解析URL很容易掉入陷阱，因此交给每个用户一个字符串并要求他们自己检查，自然会有助于解决这些问题。也许在以后的Web标准中，可以添加本机源验证功能，以便为开发人员提供更有保证的方法来验证这个行为。</p>
<p>为了安全地验证消息的来源，建议使用可信任的HTTPS源的静态列表。因为没有它，扩展程序可能很容易受到<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener">中间人攻击</a>。以下是执行这个操作的安全代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var trusted_origins = [</span><br><span class="line">    &quot;https://trusteddomain.com&quot;,</span><br><span class="line">    &quot;https://www.trusteddomain.com&quot;,</span><br><span class="line">    &quot;https://extension.trusteddomain.com&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">if( trusted_origins.includes( received_message.origin ) ) &#123;</span><br><span class="line">    // We can trust this message came from the right place</span><br><span class="line">    process_message( received_message );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样可以使外围区域较小，并在检查来源是否可信时只留下很小的错误空间。<br>当然，许多开发人员更愿意简单地将主域的所有子域列入白名单中，这样他们就不必更改源代码来添加新的主机名。虽然我建议最好别这样做（原因下面会讨论），但这样做的安全代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Pull out the message origin</span><br><span class="line">var message_origin = received_message.origin;</span><br><span class="line"></span><br><span class="line">// Specify your trusted domain</span><br><span class="line">var base_domain = &quot;trusteddomain.com&quot;;</span><br><span class="line"></span><br><span class="line">if( message_origin.startsWith( &quot;https://&quot; ) &amp;&amp; ( message_origin.edsWith( &quot;.&quot;[b] + base_domain ) || message_origin === &quot;https://&quot; + base_domain ) ) &#123;</span><br><span class="line">    // Message is HTTPS and a sub-domain, trust it.</span><br><span class="line">    process_message( received_message );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码并不难，它只是确保源既是HTTPS又是可信基域的子域，或者就只是基域本身。<br>最后，记住需要检查的是消息事件<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">源</a>，这同样也很重要。入站消息具有source属性，它是对发送它的窗口的引用。大多数情况下，内容脚本假设消息的发送者与内容脚本运行的窗口相同。因此，添加下面所示的简单的检查非常重要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Check to make sure the sender is the window we expect.</span><br><span class="line">// If it’s not, return immediately.</span><br><span class="line">if( received_message.source !== window ) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的检查确保了发送消息的窗口与运行内容脚本的窗口是相同的。如果不相同，则脚本会立即返回而不会继续处理消息。开发人员常犯的一个错误是不检查消息的来源并根据收到的消息的内容来执行DOM操作。这意味着另一个页面有可能会向目标站点发送恶意的消息，以通过内容脚本强制执行不安全的DOM操作，从而导致XSS漏洞。由于存在边界情况，您不希望与内容脚本具有相同的源窗口，但绝大多数都应该要有这个简单的检查。</p>
<h4 id="君子不立危墙"><a href="#君子不立危墙" class="headerlink" title="君子不立危墙"></a>君子不立危墙</h4><p>既然我已经向您展示了确保某些东西是您信任域的子域的安全代码，我想还是要花一点时间来讨论一下外围区域（surface area）。<br>通常情况下，您会看到只允许从Chrome扩展程序所有者拥有的域的子域中调用特定的Chrome扩展API的扩展程序，这种模式通常被当作是对开发人员有用的模式，因为他们可以更轻松地更改其网站的代码，以便实现无需更新扩展程序本身，以便对Chrome扩展程序的API进行不同的调用。 一旦您将这个想法付诸实践，通常下一步就是允许来自可信基域的任何子域的特定API的调用。</p>
<p>当使用<a href="https://developer.chrome.com/apps/messaging#external-webpage" target="_blank" rel="noopener">external_connectable</a>指令时，这个行为也很容易落入陷阱。这个指令指出了哪些来源可以将消息发送到扩展程序的后台页面。即使在官方文档中，<a href="https://developer.chrome.com/apps/messaging#external-webpage" target="_blank" rel="noopener">提供的示例</a>也如下所示，它允许基域的所有子域通过HTTP或HTTPS发送消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;externally_connectable&quot;: &#123;</span><br><span class="line">  &quot;matches&quot;: [&quot;*://*.example.com/*&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从开发的角度来看，这些似乎都很合理。然而，开发人员会将安全屏障从强力锁定的后台页面高效地移到其域的任何子域。这意味着如果攻击者在可信域的任何子域上执行任意JavaScript，则攻击者可以完全劫持这些特权调用。这可能有多种方式：</p>
<ul>
<li>任何子域上的网页都容易受到跨站点脚本（XSS）漏洞的攻击。</li>
<li>攻击者能够将HTML文件上传到包含恶意代码的任何子域。</li>
<li>任何子域都容易受到接管漏洞的影响，因为它<a href="https://thehackerblog.com/the-orphaned-internet-taking-over-120k-domains-via-a-dns-vulnerability-in-aws-google-cloud-rackspace-and-digital-ocean/index.html" target="_blank" rel="noopener">指向旧的IP地址，未分配的云资源，过期域名的CNAME</a>等。</li>
</ul>
<p>在任何这些子域中哪怕是只弄错一次也会导致Chrome扩展程序变得非常危险。把这个和所有保护措施（例如CSP）和Chrome扩展背景页面的阻止网页导航相比较，自然就相形见绌了。</p>
<p>我在<a href="https://chrome.google.com/webstore/detail/zenmate-vpn-best-cyber-se/fdcgdnkidjaadafnichfpabhfomcebme?hl=en" target="_blank" rel="noopener">ZenMate VPN Chrome扩展程序</a>中发现的一个重要的漏洞中可以看到这个问题，这是一个很好的例子（在撰写本文时，它大约有350万用户）。下面是他们（以前）易受攻击的manifest.json的摘录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">...trimmed for brevity...</span><br><span class="line">&#123;</span><br><span class="line">  &quot;js&quot;: [</span><br><span class="line">    &quot;scripts/page_api.js&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;matches&quot;: [</span><br><span class="line">    &quot;*://*.zenmate.com/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.ae/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.ma/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.dk/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.at/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.ch/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.de/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.li/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.ca/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.co.uk/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.ie/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.co.nz/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.com.ar/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.cl/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.co/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.es/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.mx/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.com.pa/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.com.pe/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.com.ve/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.fi/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.fr/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.co.il/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.in/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.hu/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.co.id/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.is/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.it/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.jp/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.kr/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.lu/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.lt/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.lv/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.my/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.be/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.nl/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.pl/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.com.br/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.pt/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.ro/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.com.ru/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.se/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.sg/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.com.ph/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.com.tr/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.pk/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.vn/*&quot;,</span><br><span class="line">    &quot;*://*.zenmate.hk/*&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;run_at&quot;: &quot;document_start&quot;</span><br><span class="line">&#125;</span><br><span class="line">...trimmed for brevity...</span><br></pre></td></tr></table></figure></p>
<p>内容脚本<code>page_api.js</code>允许对扩展程序的特权API进行调用，以便执行诸如检索用户信息、白名单站点，从而使它们不被代理、以及切换用户是否需要连接到VPN之类的操作。在以上给定几十个域的列表中，有很多外围区域可能会被利用。为了劫持这个扩展程序，我们需要在任意的子域上，在这几十个域中的任何一个域上使用XSS。</p>
<p>然而，事实证明，我们甚至不需要这样做。其中一个域名ZeMat.Li已经过期并对外开放注册。在购买它并为其建立网站之后，提取用户信息所需的全部工作就是在这个白名单域上运行以下Payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Make call to Content Script to get all user data</span><br><span class="line">__zm.getData(function(results) &#123;</span><br><span class="line">    console.log(</span><br><span class="line">        results</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Turn off VPN</span><br><span class="line">__zm.toggle(false);</span><br></pre></td></tr></table></figure></p>
<p>使用这个Payload，我们可以检索所有用户的信息（他们的身份验证令牌，电子邮件地址等），并且可以有效地对它们进行去匿名化，从而绕过扩展程序的所有保护机制。虽然供应商以迅雷不及掩耳之势做出了响应并且解决了这个问题，但这可以准确地说明当您将扩展程序控制向外移动到多个网站并扩展外围区域时可能发生的严重问题。<a href="https://thehackerblog.com/zenmate-vpn-browser-extension-deanonymization-hijacking-vulnerability-3-5-million-affected-users/index-2.html" target="_blank" rel="noopener">如需详细了解详情，请参阅此文章</a>。</p>
<h4 id="正确的URL解析"><a href="#正确的URL解析" class="headerlink" title="正确的URL解析"></a>正确的URL解析</h4><p>一些情况下，开发人员可能会发现自己正在解析给定的URL，需要查看它是否来自可信任的来源。这可以通过使用诸如<a href="https://developer.chrome.com/extensions/tabs#method-get" target="_blank" rel="noopener">chrome.tabs.get()</a>之类的API来实现，该API在查询的选项卡上返回充满元数据的<a href="https://developer.chrome.com/extensions/tabs#type-Tab" target="_blank" rel="noopener">Tab对象</a>。开发人员通常会尝试通过正则表达式解析这个对象的url属性，以查看它是否是他们信任的站点。正如我们之前看到的，解析URL是一份棘手的工作，很难做到正确无误。这个问题的核心在于，您编写的用于提取URL源代码的代码可能与Chrome内部执行的代码不同，从而致使代码被绕过。</p>
<p>从给定的URL中巧妙地拉出来源的一种简洁方法是使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/URL" target="_blank" rel="noopener">URL()</a>构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Input URL</span><br><span class="line">var input_url = &quot;https://trusted-domain.com/example-url/?red=blue#yellow&quot;;</span><br><span class="line"></span><br><span class="line">// Safely check to see if a URL matches a target origin</span><br><span class="line">function check_origin_match( input_url, target_origin ) &#123;</span><br><span class="line">    var parsed_url = new URL(</span><br><span class="line">        input_url</span><br><span class="line">    );</span><br><span class="line">    return ( parsed_url.origin === target_origin );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if( check_origin_match( input_url, &quot;https://trusted-domain.com&quot; ) ) &#123;</span><br><span class="line">    // URL is from a trusted origin!</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // Not from a trusted origin.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码很特殊，因为它将工作转移到了Chrome的URL解析器以从给定的URL中检索来源。这可确保您的代码和Chrome代码就给定网址的实际来源达成一致。您可以自己将URL传递给URL构造函数，并使用上面提供的一些代码来检查origin属性，而不是使用上面的<code>check_origin_match()</code>函数。由于URL尚未被解析出来，故而您应该安全地检查它的来源，最终的URL对象还包含了用于散列的有用的解析字段，主机名，URL路径，参数以及其他信息。</p>
<h4 id="点击劫持以及web-accessible-resources的使用注意事项"><a href="#点击劫持以及web-accessible-resources的使用注意事项" class="headerlink" title="点击劫持以及web_accessible_resources的使用注意事项"></a><strong>点击劫持以及web_accessible_resources的使用注意事项</strong></h4><p><a href="https://developer.chrome.com/extensions/manifest/web_accessible_resources" target="_blank" rel="noopener">web_accessible_resources</a>指令是指哪些资源，如扩展页面，图像和JavaScript可以通过任意网站被嵌入。前面已经提到，默认情况下，任意网页都不能在iframes中嵌入扩展页面，也不能通过脚本或样式表标签来发送它们。这条指令的示例用法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...trimmed for brevity...</span><br><span class="line">  &quot;web_accessible_resources&quot;: [</span><br><span class="line">    &quot;images/*.png&quot;,</span><br><span class="line">    &quot;style/double-rainbow.css&quot;,</span><br><span class="line">    &quot;script/double-rainbow.js&quot;,</span><br><span class="line">    &quot;script/main.js&quot;,</span><br><span class="line">    &quot;templates/*&quot;</span><br><span class="line">  ],</span><br><span class="line">  ...trimmed for brevity...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的示例中不难看出，您不仅可以指定特定的资源，还可以使用通配符资源文件夹。但是，有时开发人员会遇到Chrome阻止他嵌入扩展资源的问题，并且会执行以下操作：</p>
<pre><code>{
  ...trimmed for brevity...
  &quot;web_accessible_resources&quot;: [
    &quot;*&quot;,
  ],
  ...trimmed for brevity...
}
</code></pre><p>这是一项相当有效的策略，这意味着本质上所有的Chrome扩展资源现在都可以嵌入到第三方网站。问题是当您的扩展程序包含有执行特权操作的页面并且也属于web_accessible_resources策略的页面时，这会变成一个<a href="https://www.owasp.org/index.php/Clickjacking" target="_blank" rel="noopener">点击劫持</a>(clickjacking)漏洞。由点击劫持引起的扩展程序漏洞的一个很好的例子可以参阅<a href="https://thehackerblog.com/steam-fire-and-paste-a-story-of-uxss-via-dom-xss-clickjacking-in-steam-inventory-helper/index-2.html" target="_blank" rel="noopener">有关Steam Inventory Helper中的UXSS</a>的这篇文章。</p>
<h4 id="使用tarnish自动化审核流程"><a href="#使用tarnish自动化审核流程" class="headerlink" title="使用tarnish自动化审核流程"></a><strong>使用tarnish自动化审核流程</strong></h4><p>由于Chrome扩展程序的独特结构，我决定写一个服务工具来帮助开发人员和安全研究人员审核Chrome扩展程序中的安全漏洞。我把这个工具叫做tarnish，它具有以下功能：</p>
<ul>
<li>从所提供的Chrome应用商店链接中提取任意一个Chrome扩展程序。</li>
<li><a href="https://developer.chrome.com/extensions/manifest" target="_blank" rel="noopener">manifest.json</a>查看器：只显示扩展程序清单的JSON-prettified版本。</li>
<li>指纹分析：检测<a href="https://developer.chrome.com/extensions/manifest/web_accessible_resources" target="_blank" rel="noopener">web_accessible_resources</a>并自动生成识别Chrome扩展指纹的JavaScript。</li>
<li>潜在的点击劫持分析：使用 <a href="https://developer.chrome.com/extensions/manifest/web_accessible_resources" target="_blank" rel="noopener">web_accessible_resources</a>指令集检测扩展程序的HTML页面。这些可能会受到点击劫持的影响，具体得看页面的用途。</li>
<li>权限警告查看器：显示所有Chrome权限的警告提示列表，它们在用户尝试安装扩展程序时显示。</li>
<li>危险功能：显示可能被攻击者利用的危险功能的位置（例如 innerHTML，chrome.tabs.executeScript等功能）。</li>
<li>入口点：显示扩展程序在用户/外部输入的位置。这对于了解扩展程序的外围区域以及查找将恶意制作的数据发送到扩展程序的可能点是非常有帮助的。</li>
</ul>
<ul>
<li>危险功能和入口点扫描仪的生成警报都有以下内容：<ul>
<li>引起警报的相关代码段和行。</li>
<li>问题说明。</li>
<li>“查看文件”按钮，用于查看包含代码的完整源文件。</li>
<li>警报文件的路径。</li>
<li>警报文件的完整Chrome扩展程序URI。</li>
<li>警报文件的类型，比如背景页面脚本，内容脚本，浏览器控件等。</li>
<li>如果易受攻击的代码行位于JavaScript文件中，就会包含警报文件的所有页面路径以及这些页面的类型和<a href="https://developer.chrome.com/extensions/manifest/web_accessible_resources" target="_blank" rel="noopener">web_accessible_resource</a>状态。</li>
</ul>
</li>
</ul>
<ul>
<li>内容安全策略(CSP)分析器和bypass检查器：这会指出您的扩展程序的CSP中的薄弱点所在，并且还将给出白名单中的CDN绕开CSP的任何可能的方式等。</li>
<li>已知的漏洞库：它使用 <a href="https://retirejs.github.io/retire.js/" target="_blank" rel="noopener">Retire.js</a>来检查JavaScript库的已知漏洞的任何使用情况。</li>
</ul>
<ul>
<li>下载扩展程序和格式化版本。<ul>
<li>下载原始扩展程序。</li>
<li>下载美化版的扩展程序（自动美化HTML和JavaScript）。</li>
</ul>
</li>
</ul>
<ul>
<li>自动缓存扫描结果，第一次运行扩展程序扫描时会耗费大量时间。假设扩展程序未更新，那么第二次由于结果已经被缓存，运行几乎是即时完成的。</li>
<li>可链接的报告网址，可以轻松地将其他人链接到由tarnish产生的扩展程序报告中。</li>
</ul>
<p>所有这些功能都是为了将我在审核各种Chrome扩展程序时必须采取的烦人的机械式重复性操作自动化而创建的。如果您对该工具的任何功能有建议或者存在bug，请随时与我联系，我会尽快排查。</p>
<h1 id="点击此处试用Chrome扩展程序分析仪tarnish"><a href="#点击此处试用Chrome扩展程序分析仪tarnish" class="headerlink" title="点击此处试用Chrome扩展程序分析仪tarnish"></a><a href="https://thehackerblog.com/tarnish/index.html" target="_blank" rel="noopener">点击此处试用Chrome扩展程序分析仪tarnish</a></h1></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ginove</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ginove.github.io/2018/09/09/突破限制-一份安全编写和审计Chrome扩展程序的指南-下/">https://ginove.github.io/2018/09/09/突破限制-一份安全编写和审计Chrome扩展程序的指南-下/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ginove.github.io" target="_blank">Ginove</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/技术文章/">技术文章</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/09/26/2019届华为网络安全校招面经/"><i class="fa fa-chevron-left">  </i><span>2019届华为网络安全校招面经</span></a></div><div class="next-post pull-right"><a href="/2018/09/09/突破限制-一份安全编写和审计Chrome扩展程序的指南-上/"><span>突破限制-一份安全编写和审计Chrome扩展程序的指南(上)</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  owner: 'Ginove',
  repo: 'ginove.github.io',
  oauth: {
    client_id: '8c123d3802de7afc9635',
    client_secret: 'ec2035d90649bfa051c5b990447e10a0c70755b7'
  }
})
gitment.render('gitment-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2018 By Ginove</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/algolia.js"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>